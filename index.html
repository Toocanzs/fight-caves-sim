<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Fight Caves Simulator</title>
		<style>
			body { margin: 0; background-color: black;}
		</style>
		<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

		<script type="importmap">
		  {
			"imports": {
			  "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
			  "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
			}
		  }
		</script>
	</head>
	<body>
		<script type="module">

			import * as THREE from 'three';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { FlyControls } from 'three/addons/controls/FlyControls.js';
			import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
			import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

			const HEIGHT_DIV = 100;

			let camera, scene, renderer;

			const container = document.createElement( 'div' );
			document.body.appendChild( container );

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 1000 );
			camera.position.set( 28, 31, 66);
			camera.lookAt( 30, 4, 32);

			scene = new THREE.Scene();
			let heights;
			function getHeightSafe(z, x, y) {
				if (x < 0) x = 0;
				if (y < 0) y = 0;
				if (z < 0) z = 0;

				if (x >= 64) x = 63;
				if (y >= 64) y = 63;
				if (z >= 4) z = 3;

				if (!heights[z][x]) return 0;
				if (!heights[z][x][y]) return 0;
				// The /100 *should* be /128 but for similar reasons since the heights we export are not scale by the 1.28 times they're just 100 times larger? idk but this works perfectly
				return -heights[z][x][y] / HEIGHT_DIV; // Heights are updside down in runescape for whatever reason
			}

			const pointer = new THREE.Vector2();
			const raycaster = new THREE.Raycaster();
			let tileCollisions = [];
			let tileHighlightMeshes = Array(64);
			for (let i = 0; i < 64; i++) {
				tileHighlightMeshes[i] = Array(64).fill(undefined);
			}

			let promises = [];

			promises.push(fetch('model/rs/fight-caves/heights.json')
				.then(response => response.text())
				.then((data) => {
					heights = JSON.parse(data)

					// Flip y so we don't have to deal with negatives everywhere
					for (let z = 0; z < heights.length; z++) {
						for(let x = 0; x < heights[z].length; x++) {
							heights[z][x].reverse();
						}
					}

					let z = 0;
					let plane = heights[z];
					for (let x = 0; x < plane.length; x++) {
						for (let y = 0; y < plane[x].length; y++) {
							let tileEdges;
							{
								const edgeGeometry = new THREE.BufferGeometry();

								const vertices = new Float32Array( [
									x + 0.0,  getHeightSafe(z, x + 0, y + 1), y + 1.0,
									x + 1.0,  getHeightSafe(z, x + 1, y + 1), y + 1.0,
									x + 1.0,  getHeightSafe(z, x + 1, y + 0), y + 0.0,
									x + 0.0,  getHeightSafe(z, x + 0, y + 0), y + 0.0,
								] );

								const indices = [
									0, 1,
									1, 2, 
									2, 3,
									3, 0 
								];

								edgeGeometry.setIndex( indices );
								edgeGeometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

								const material = new THREE.LineBasicMaterial( { color: 0xffffff} );
								material.depthTest = false;
								material.depthWrite = false;
			
								tileEdges = new THREE.LineSegments(edgeGeometry, material ); 
								tileEdges.renderOrder = 9999;
							}

							let terrainMesh;
							{
								const geometry = new THREE.BufferGeometry();

								const vertices = new Float32Array( [
									x + 0.0,   getHeightSafe(z, x + 0, y + 1), y + 1.0,
									x + 1.0,   getHeightSafe(z, x + 1, y + 1), y + 1.0,
									x + 1.0,   getHeightSafe(z, x + 1, y + 0), y + 0.0,
									x + 0.0,   getHeightSafe(z, x + 0, y + 0), y + 0.0,
								] );

								const indices = [
									0, 1, 2,
									2, 3, 0,
								];

								geometry.setIndex( indices );
								geometry.setAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

								const material = new THREE.MeshBasicMaterial();
								material.depthTest = false;
								material.depthWrite = false;
								material.side = THREE.DoubleSide;
								material.transparent = true;
								material.opacity = 0.4;
								material.side = THREE.DoubleSide;
								terrainMesh = new THREE.Mesh(geometry, material);
							}

							terrainMesh.add(tileEdges); // Parent edges to the base mesh
							terrainMesh.tileCoords = {x: x, y: y};
							tileHighlightMeshes[x][y] = {edges: tileEdges, base: terrainMesh};
							tileCollisions.push(tileHighlightMeshes[x][y].base);
						}
					}

					const directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
					scene.add( directionalLight );

					function onPointerMove(event) {
						pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
						pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
					}

					window.addEventListener('mousemove', onPointerMove);

					
			}));

			function loadNpc(folder, glbFile) {
				return new Promise((resolve, reject) => {
					const loader = new GLTFLoader().setPath( 'model/rs/fight-caves/npcs/'+folder+'/' );
					let promise = loader.load( glbFile, function ( gltf ) {

						var model = gltf.scene;
						model.traverse((o) => {
							if (!o.isMesh) return;
							o.geometry.computeVertexNormals();
						});
						gltf.scene.scale.set(1.0/64, 1.0/64, 1.0/64);
						scene.add( gltf.scene );
						resolve(model);
					} );
				});
			}

			let oldManPromise = loadNpc("old-man", "old-man.glb");
			promises.push(oldManPromise);

			//promises.push(loadNpc("180", "180.glb"));
			//promises.push(loadNpc("90", "90.glb"));

			function loadScene() {
				return new Promise((resolve, reject) => {
					const loader = new GLTFLoader().setPath( 'model/rs/fight-caves/' );
					promises.push(loader.load( 'scene.gltf', function ( gltf ) {

						var model = gltf.scene;
						model.traverse((o) => {
							if (!o.isMesh) return;
							
							var prevMaterial = o.material;
							o.material = new THREE.MeshBasicMaterial();
							THREE.MeshBasicMaterial.prototype.copy.call(o.material, prevMaterial);
						});

						scene.add(gltf.scene);
						gltf.scene.scale.set(1.0/1.28, 1, 1.0/1.28);
						gltf.scene.position.set(0,0,64);
						resolve(gltf.scene);
					}));
				});
			}

			promises.push(loadScene());
			
			await Promise.all(promises);

			function lerp (start, end, amt){
				return (1-amt)*start+amt*end
			}

			function getHeightInterpolated(x, y) {
				let ix = Math.floor(x);
				let iy = Math.floor(y);
				let fx = x - ix;
				let fy = y - iy;
				let plane = 0;
				
				let bl = getHeightSafe(plane, ix + 0, iy + 0);
				let br = getHeightSafe(plane, ix + 1, iy + 0);
				let tl = getHeightSafe(plane, ix + 0, iy + 1);
				let tr = getHeightSafe(plane, ix + 1, iy + 1);

				let bottom = lerp(bl, br, fx);
				let top = lerp(tl, tr, fx);
				let result = lerp(bottom, top, fy);

				return result;
			}

			let oldMan = await oldManPromise;

			renderer = new THREE.WebGLRenderer( { antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 1;
			renderer.useLegacyLights = false;
			renderer.setClearColor(0xff0f0a0a);
			container.appendChild( renderer.domElement );

			const controls = new FirstPersonControls(camera, renderer.domElement);
			controls.activeLook = true;
			controls.autoForwared = false;
			controls.constrainVertical = true;
			controls.movementSpeed = 30;
			controls.lookSpeed = Math.PI / 12;
			
			window.addEventListener( 'resize', onWindowResize );

			const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5); // soft white light
			directionalLight.position.set(-50, 10, -50);
			scene.add(directionalLight);

			const ambientLight = new THREE.AmbientLight(0x808080); // soft white light
			scene.add(ambientLight);

			var clock = new THREE.Clock();
			let t = 0;
			function loop() {
				let dt = clock.getDelta();
				t += dt;
				requestAnimationFrame(loop);
				controls.activeLook = controls.mouseDragOn;
				controls.update(dt);

				for (let i = 0; i < tileCollisions.length; i++) {
					scene.remove(tileCollisions[i]);
				}

				// Intersect tiles
				raycaster.setFromCamera( pointer, camera );
				const intersects = raycaster.intersectObjects(tileCollisions, false);
				for ( let i = 0; i < intersects.length; i ++ ) {
					if (i > 0) break; // Only first
					scene.add(intersects[i].object);
				}
				renderer.render(scene, camera);

				let sx = Math.sin(t*0.2)*15 + 39;
				let sy = Math.cos(t*0.2)*15 + 29;
				oldMan.position.set(sx, getHeightInterpolated(sx, sy),sy);
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			loop();
			
		</script>

	</body>
</html>